# We write a series of procedures with the end goal of enumerating the
# configurations corresponding to a potential W on the set of binary trees with
# n leaves.

# By a binary tree with n leaves we mean a list of lists of lists in which each
# tuple is a fork in the tree and the tupes eventually terminate with an integer
# i between 1 and n which labels the leaves in order. An example of a binary tree
# with 5 leaves is

# [1, [2, [3, [4, 5]]]]

# A configuration is a way of placing 'interactions' at the leaves, nodes, and
# edges of our trees. These come in three types:

# - A-type: which can occur at leaves and internal edges with any multiplicity.
# - B-type: of which we must have one at each internal edge.
# - C-type: whcih occur at internal vertices with any multiplicity.

# Finally, our potential W is a polynomial expression of cubic or higher degree.
# The number of varialbles in W places an upper limit on the number of A or C
# type interactions which can be place on the same location. Moreover, W
# contributes a monomial term at all A-type interactions.

###############################################################################

import itertools

###############################################################################
# Procedures:
#
#   - BinTreeGen(n): generates a list of all binary trees with n leaves.
#   - interactions(tree): lists all 'locations' on a binary tree at which
#     interactions may take place.
#   - enumerateInternalProp(T): produces a list of coupled fermion/boson
#     propagations.

###############################################################################
# STEP ZERO: GENERATE BINARY ROOTED TREES AND EXTRACT THEIR LOCATIONS
###############################################################################

def BinTreeGen(n):
    # A function which takes an integer as input and returns a list of all
    # binary rooted trees with n leaves.
    if  n <= 1:
        print('Input must be at least 1')
    else:
        return trees(n,0)

# We proceed recursiely: at the root node we consider the subtrees to the left
# and the right respectively, and cycle over the possible sizes of these
# subtrees.

def trees(n,leafnode):
    alltrees = []
    if n == 1:
        label = leafnode + 1
        return [label]       #labels the nodes acording the the standard order.
    else:
        for i in range(1,n):
            L = trees(i,leafnode)
            R = trees(n-i,leafnode+i)

            for j in range(0,len(L)):
                for k in range(0, len(R)):
                    subtree = [L[j],R[k]]
                    alltrees.append(subtree)
    return alltrees

##############################################################################

def interactions(tree):
    # Takes as input a tree with n leaves
    # Returns a list of all points on a binary rooted tree on which interactions
    # can take place, collectiely called locations.
    if type(tree) == int:
        return [tree]

    # Working recursively we compute the list of interactions as the union of
    # the list of interactions from the left and right branches of oour tree,
    # adding the interaction at the root node in the form of the entire tree.
    else:
        L = tree[0]
        R = tree[1]
        interactionlist = interactions(L) + interactions(R)
        interactionlist.append(tree)


        # Add the B-type interctions aster internal nodes
        if type(L) == list:
                interactionlist = interactionlist + [[L]]
        if type(R) == list:
                interactionlist = interactionlist + [[R]]

        # Orders the interactions in interactionlist: no actual application,
        # just makes it easier to check that the code works.
        leaf = []
        internal_edge = []
        internal_vertex = []

        for location in interactionlist:
            if type(location) == int:
                leaf.append(location)
            elif len(location) == 1:
                internal_edge.append(location)
            elif len(location) == 2:
                internal_vertex.append(location)

        interactionlist = leaf + internal_vertex + internal_edge

        return interactionlist

###############################################################################

# Given a binary rooted tree T and the list of locations of configurations on T,
# we enumerate the number of possible configurations of A, B, and C type
# interactions on T generated by a given potential W.

# We do this as follows:
#
#   1. Given a potenial W we generate a list of possible A_type interacitons
#     generated by W.
#
#   2. On a given tree T, we generate a list of all possible theta_t-x_t paths
#     i.e. lists of the form [[fermion, source, target], [x_t, psi_type, mon]]
#     where mon is the monomial of which x_t is a component, and psi_type is the
#     type of psi eaten by the A_type interaction producing the monomial.
#
#   3. Next we generate a list of all possible ways of combining these paths
#     into lists in which every internal edge of the tree is featured exactly
#     once. These form the skeleton of our configurations, called
#     pre-configurations.
#
#   4. For each pre-configuration we conbine together each of the theta_t-x_t
#     paths which share the same A_type interaction, giving lists of the form
#     [monomial source term, [theta paths]]. We test that the theta types allign
#     with the monomial to ensure that the monomial is destroyed by the associated
#     internal edges. Finally we generate a list of all possible ways to
#     append a theta path from the A_type interation to a downstream vertex.
#     The resulting paths look like
#     [monomial source term, [edge theta paths], monomial theta path].
#
#   5. To obtain bona fide configurations we we test our pre-configurations to
#     check that they
#       - Do not involve two C_type interactions of the same type on the same
#         vertex.
#       - Do not have any intersecting theta paths of the same type.
#       - Have enough Psi inuts to feed the A and C type interactions.

# We represent a potential W by its components Wcomp, i.e. such that W is given
# by x1 * Wcomp[1] + ... + xn * Wcomp[n].

###############################################################################
# STEP ONE: COLLECT DATA TO BUILD POTENTIAL CONFIGURATIONS
###############################################################################

def Edge_Patterns(T, potential, numvars):
    locations = interactions(T)
    edges = Edges(T)
    vertices = Vertices(T)
    leaves = Leaves(T)
    leaves_and_edges = edges + leaves
    feynmann = Feynmann(potential, numvars)

    List = []
    for e in edges:
        for t in range(0,numvars):
            templist = []
            temp_append = templist.append
            for v in vertices:
                # Check that v is downstream from e and that e leads into the
                # right hand side of v.
                vertex1_above_right = [v[1]]
                if IsAbove(e, vertex1_above_right) == 1:
                    # choose a location where the boson originates
                    for u in leaves_and_edges:
                        # check that u is upstream from e and not equal to e
                        if u != e and IsAbove(u,e) == 1:
                            # generate a list of A-type interactions which could
                            # create a monomial with am x_t component and which
                            # are also compatible with the tree locations involved
                            potenial_A_types = valid_A_types(e,u,t,T,potential)
                            for type in potenial_A_types:
                                mon = type[0]
                                theta_type = type[1]
                                psi_type = type[2]
                                c1 = [('theta', t), e, v]
                                a = [u, psi_type, mon, theta_type]
                                # Here (,) takes a particle type on one side
                                # and a label on the other.
                                temp_append([c1, a])
            List = List + templist
    return(List)

def PropEdge(T, e, potential, numvars):
    # Pulls apart the output of enumerateInternalProp by grouping lists with the
    # same edge term into a list. This gets the data ready to feed into a list
    # product in PreConfig.
    List = Edge_Patterns(T, potential, numvars)
    templist = []
    temp_append = templist.append
    for element in List:
        if element[0][1] == e:
            temp_append(element)
    return(templist)

def PreConfig(T, potential, numvars):
    # Collect together one pattern for each edge in a product of lists. Such
    # coherent collections will be called 'pre-configurations'. The output is a
    # list of all pre-configurations that can be put on the tree T.

    # Each pre-configuration is a list of lists of the form
    #        [a_type, [b_types], c_type]
    # where the c_type in a list specifying the path of the theta term produced
    # by the a_type interaction.

    Lists = []
    Lists_append = Lists.append
    for edge in Edges(T):
        Lists_append(PropEdge(T, edge, potential, numvars))
    tempprod = prodlist(Lists)

    prod = []
    prod_append = prod.append
    for config in tempprod:
        glued_config = Glue(config)
        if MonomCheck(glued_config, potential) == 1:
            if C_Test1(glued_config, T, potential) == 1:
                if OverlapsThetaPaths(ThetaPaths1(glued_config), T) == 0:
                    if Psi_Test1(glued_config, T, potential) == 1:
                        prod_append(glued_config)
    # Above we have applied some of the tests which we wil apply again later.
    # Despite the apparent redundancy this actually means we have fewer lists
    # being fed into the list product in the AddC procedure, greatly speeding
    # things up.

    Cprod = []
    for item in prod:
        Cprod = Cprod + AddC(item, T)

    if len(Cprod) == 1:
        return([Cprod])
    else:
        return(Cprod)

###############################################################################

def MonomCheck(config, potential):
    # Takes a pre-configuration and checks that the edge paths are able to
    # kill the monomials in the A_type interactions.
    numvars = len(potential[0])
    count = 0
    for path in config:
        a = path[0]
        b_types = path[1]
        countlist = Zeros(numvars)
        for item in b_types:
            countlist[item[0][1]] += 1
        if countlist == a[2]:
            count += 1
    if count == len(config):
        return(1)
    else:
        return(0)

# First C_type interaction test
def ThetaPaths1(config):
    templist = []
    for pattern in config:
        templist = templist + pattern[1]
    return(templist)
def C_Test1(config, T, potential):
    # Check that each vertex of T has no more than numvars C-type interactions, and
    # that they are all different. Equivalently, this checks that there are no more
    # than numvars theta_i terms coming into any given vertx, and that we don't have
    # two theta_i's of the same type being 'eaten' by the same vertex.
    numvars = len(potential[0])
    vertex_counter = []
    theta_counter = []
    append1 = vertex_counter.append
    append2 = theta_counter.append
    for vertex in Vertices(T):
        count = 0
        thetas = Zeros(numvars)
        for path in ThetaPaths1(config):
            if vertex == path[2]:
                thetatype = path[0][1]
                thetas[thetatype] += 1
                count += 1
        append1(count)
        append2(max(thetas))
    if max(vertex_counter) <= numvars:
        if max(theta_counter) <= 1:
            return(1)
    else:
        return(0)

# First Psi test
def C_types1(config):
    # Extracts a list of all C-type interactins in config, giving a list of
    # tuples (location, psi_type).
    templist = []
    for item in config:
        for path in item[1]:
            templist.append((path[2], path[0][1]))
    return(templist)
def Psi_Test1(config, T, potential):
    # Checks that there are enough psi input terms in T to feed the A and C type
    # interactions in in config.
    numvars = len(potential[0])
    AorC = A_types(config) + C_types1(config)
    count = 0
    for ints in AorC:
        if Enough_Leaves_Above1(ints, config, T, numvars) == 0:
            count += 1
    if count == 0:
        return(1)
    else:
        return(0)

def Interactions_Above1(loc, config):
    # Given an interaction which is part of a configuration config on a
    # tree T, returns a list of the A or C type interactions which lie above
    # it on T. Note: this includes he given interaction.

    # Collect a list of all A or C type interactions above. Note: this includes
    # our given interaction.
    A_or_C = A_types(config) + C_types1(config)
    templist = []
    for item in A_or_C:
        if IsAbove(Location(item), loc) == 1:
            templist.append(item)
    return(templist)

def Enough_Leaves_Above1(interaction, config, T, numvars):
    # Given an A or C type interaction, tests whether there are enough leaves
    # above it in the tree to feed it and the interactions between it and
    # the leaves.
    loc = Location(interaction)
    if IsVertex(loc) == 1:
        if IsInput(loc[0]) == 1:
            numleaves = 1
            leaf = loc[0]
            leafints = Interactions_Above1(leaf, config)
            if len(leafints) > 0:
                ints = [interaction] + leafints
            else:
                ints = [interaction]
        else:
            edgeints = Interactions_Above1([loc[0]], config)
            ints = [interaction] + edgeints
    else:
        ints = Interactions_Above1(Location(interaction), config)

    numleaves = len(Leaves_Above(loc, T))

    if len(ints) > numvars*numleaves:
        return(0)

    typecount = Zeros(numvars)
    for item in ints:
        for i in range(0, numvars):
            if item[1] == i:
                typecount[i] += 1

    if max(typecount) <= numleaves:
        return(1)
    else:
        return(0)

###############################################################################

def AddC(config, T):
    # Takes a preconfiguration and returns a list of ways of adding a C-type
    # interaction to each path to consme the theta produced
    templist = []
    append = templist.append
    for item in config:
        temp = []
        temp_append = temp.append
        a = item[0]
        loc = a[0]
        for v in Vertices(T):
            vertex_above_right = [v[1]]
            if IsAbove(loc, vertex_above_right) == 1:
                temp_append(item + [[('theta', a[3]), loc, v]])
        append(temp)
    product = prodlist(templist)
    return(product)

def Glue(config):
    # Takes a list of paths as output by edge_patterns and combines together
    # those with the same A_type source term
    templist = []
    a = []
    append_a = a.append
    append = templist.append
    for item in config:
        append_a(item[1])
    a_types = Reduce(a)
    for item in a_types:
        b_types = []
        b_append = b_types.append
        for path in config:
            if path[1] == item:
                b_append(path[0])
        temppath = [item, b_types]
        append(temppath)
    return(templist)

###############################################################################
# MAIN PROCEDURES
###############################################################################

def N(edge, config, T):
    # counts the number of thetas and x_i terms entering a given edge. Note that
    # x_i^n is counted n times.
    theta_count = 0
    deg_count = 0
    for a in A_types(config):
        if IsAbove(Location(a), edge) == 1:
            theta_count += 1
            deg_count += sum(a[2])
    for c in C_types(config):
        if IsAbove(Location(c), edge) == 1:
            theta_count -= 1
    return(theta_count + deg_count)

def EnumerateConfigs(T, potential):
    # Counts the number of confgurations associated to a given potential on a
    # given tree T.
    return(len(Configs(T, potential)))

def Configs(T, potential):
    # Takes as input a tree T and a potential with standard decomposition.
    # First generates a list of pre-configurations and then filters out those
    # which satusfy the constraints.
    numvars = len(potential[0])
    templist = []
    preconfig = PreConfig(T, potential, numvars)
    for config in preconfig:
        if C_Test(config, T, potential) == 1:
            if Psi_Test(config, T, potential) == 1:
                if OverlapsThetaPaths(ThetaPaths(config), T) == 0:
                    templist.append(config)
    return(templist)


def C_Test(config, T, potential):
    # Check that each vertex of T has no more than numvars C-type interactions, and
    # that they are all different. Equivalently, this checks that there are no more
    # than numvars theta_i terms coming into any given vertx, and that we don't have
    # two theta_i's of the same type being 'eaten' by the same vertex.
    numvars = len(potential[0])
    vertex_counter = []
    theta_counter = []
    append1 = vertex_counter.append
    append2 = theta_counter.append
    for vertex in Vertices(T):
        count = 0
        thetas = Zeros(numvars)
        for path in ThetaPaths(config):
            if vertex == path[2]:
                thetatype = path[0][1]
                thetas[thetatype] += 1
                count += 1
        append1(count)
        append2(max(thetas))
    if max(vertex_counter) <= numvars:
        if max(theta_counter) <= 1:
            return(1)
    else:
        return(0)

def OverlapsThetaPaths(theta_paths, T):
    # For each theta path in t, tests that it has no intersections of
    # theta paths of the same type.
    overlapcount = 0
    for path1 in theta_paths:
        for path2 in theta_paths:
            if path1 != path2:
                if len(Overlaps(path1, path2, T)) > 0 and path1[0][1] == path2[0][1]:
                    overlapcount += 1
    return(overlapcount)

def Psi_Test(config, T, potential):
    # Checks that there are enough psi input terms in T to feed the A and C type
    # interactions in in config.
    numvars = len(potential[0])
    A = A_types(config)
    C = C_types(config)
    count = 0
    for ints in A:
        if Enough_Leaves_AboveA(ints, config, T, numvars) == 0:
            count += 1
    for ints in C:
        if Enough_Leaves_AboveC(ints, config, T, numvars) == 0:
            count += 1
    if count == 0:
        return(1)
    else:
        return(0)

def Enough_Leaves_AboveC(interaction, config, T, numvars):
    loc = Location(interaction)

    if IsInput(loc[0]) == 1:
        numleaves = 1
        leaf = loc[0]
        leafints = Interactions_Above(leaf, config)
        if len(leafints) > 0:
            ints = [interaction] + leafints
        else:
            ints = [interaction]
    else:
        numleaves = len(Leaves_Above([loc[0]], T))
        edgeints = Interactions_Above([loc[0]], config)
        ints = [interaction] + edgeints

    if len(ints) > numvars*numleaves:
        return(0)

    typecount = Zeros(numvars)
    for item in ints:
        for i in range(0, numvars):
            if item[1] == i:
                typecount[i] += 1

    if max(typecount) <= numleaves:
        return(1)
    else:
        return(0)

def Enough_Leaves_AboveA(interaction, config, T, numvars):

    loc = Location(interaction)
    ints = Interactions_Above(Location(interaction), config)
    numleaves = len(Leaves_Above(loc, T))
    if len(ints) > numvars*numleaves:
        return(0)

    typecount = Zeros(numvars)
    for item in ints:
        for i in range(0, numvars):
            if item[1] == i:
                typecount[i] += 1

    if max(typecount) <= numleaves:
        return(1)
    else:
        return(0)

###############################################################################
# OPERATIONS ON CONFIGS
###############################################################################

def C_types(config):
    # Extracts a list of all C-type interactins in config, giving a list of
    # tuples (location, psi_type).
    templist = []
    for item in config:
        if type(item[1][0][1]) == int:
            templist.append((item[1][2], item[1][0][1]))
        else:
            for path in item[1]:
                templist.append((path[2], path[0][1]))
        templist.append((item[2][2], item[2][0][1]))
    return(templist)

def B_types(config):
    # Extracts a list of all B-type interactions in config, giving a list of
    # tuples (location, type)
    templist = []
    for item in config:
        for path in item[1]:
            templist.append(path[1], path[0][1])
    return(templist)

def A_types(config):
    # Extracts a list of all A-type interactions in config, giving a list of
    # tuples (location, psi_type, mon, theta_type)
    templist = []
    for item in config:
        templist.append(item[0])
    return(templist)

def Location(interaction):
    # Given an intreractions of type A, B, or C, returns its location.
    return(interaction[0])

def InteractionType(interaction):
    # Given an A or C type interaction, returns the phi_type of the interaction.
    return(interaction[1])

def Interactions_Above(loc, config):
    # Given an interaction which is part of a configuration config on a
    # tree T, returns a list of the A or C type interactions which lie above
    # it on T. Note: this includes he given interaction.

    # Collect a list of all A or C type interactions above. Note: this includes
    # our given interaction.
    A_or_C = A_types(config) + C_types(config)
    templist = []
    for item in A_or_C:
        if IsAbove(Location(item), loc) == 1:
            templist.append(item)
    return(templist)

def ThetaPaths(config):
    templist = []

    for pattern in config:
        if type(pattern[1][0][1]) == int:
            templist.append(pattern[1])
        else:
            templist = templist + pattern[1]
        templist.append(pattern[2])
    return(templist)

###############################################################################
# MONOMIAL PREPARATION AND MANIPULATION
###############################################################################

def Feynmann(pot, numvars):
    # Give a potential in with standard decomposition (in the form of a tuple
    # of tuples), returns a list of all A-type interactions, i.e. a list of
    # tuples (mon, theta_type, psi_type)
    potential = []
    for i in range(0,len(pot)):
        potential.append(list(pot[i]))
    templist = []
    for i in range(0, len(potential)):
        mon = potential[i]
        for index in range(0,numvars):
            if mon[index] > 0:
                derived_mon = Derive(index, mon)
                templist.append((derived_mon, index, i))
    return(templist)

def valid_A_types(edge, loc, t, T, potential):
    # Given an edge where a boson of type t is destroyed and a chosen vertex
    # loc at which the boson was created, generates a list of possible A-type
    # interactions which could lie at loc.
    numvars = len(potential[0])
    h_loc = Height(loc, T)
    h_edge = Height(edge, T)
    templist = []
    for type in Feynmann(potential, numvars):
        # Check that type produces a monomial with nonzero x_t term and that
        # the order of the monomial is large enough to survive to reach edge
        # sand small enough to be destrpyed by the edges below loc in the tree.
        if type[0][t] > 0 and sum(type[0]) in range(h_loc - h_edge, h_loc + 1):
            templist.append(type)
    return(templist)

###############################################################################
# TREE OPERATIONS
###############################################################################

# Extracts the edges, vartices, and leaves form the location list of the tree.

def Edges(T):
    templist = []
    for loc in interactions(T):
        if IsEdge(loc) == 1:
            templist.append(loc)
    return(templist)

def Vertices(T):
    templist = []
    for loc in interactions(T):
        if IsVertex(loc) == 1:
            templist.append(loc)
    return(templist)

def Leaves(T):
    templist = []
    for loc in interactions(T):
        if IsInput(loc) == 1:
            templist.append(loc)
    return(templist)

# Three procedures which decide whether a given locaiton is a leaf, an internal
# edge, ot an internal vertex respectively.

def IsInput(x):
    if type(x) == int:
        return(1)
    else:
        return(0)

def IsEdge(x):
    if type(x) == list:
        if len(x) == 1:
            return(1)
        else:
            return(0)
    else:
        return(0)

def IsVertex(x):
    if type(x) == list:
        if len(x) == 2:
            return(1)
        else:
            return(0)
    else:
        return(0)


def IsAbove(x,y):
    # Given two locations x and y on a tree T, decides whether x is above (including
    # equal to) y in T.
    if type(y) != list:
        if x == y:
            return(1)
        else:
            return(0)
    if x == y:
        return(1)
    if type(x) == list:
        if len(x) == 1:
            if x[0] == y:
                return(0)
            else:
                return(IsAbove(x[0],y))
    if len(y) == 1:
        return(IsAbove(x,y[0]))
    if len(y) == 2:
        l = IsAbove(x,y[0])
        r = IsAbove(x,y[1])

        if l + r >= 1:
            return(1)
        edge_aboveright = y[1]
        edge_aboveleft = y[0]

        if edge_aboveleft == x or edge_aboveright == x:
            return(1)
        else:
            return(0)

def count_edges_below(u, T):
    # Gives the number of edges below a location u. Note: Does NOT include u, this
    # wluld cause problems otherwise.
    count = 0
    for edge in Edges(T):
        if IsAbove(u,edge) and u != edge:
            count += 1
    return(count)

def IsBetween(a,x,y):
    # Determines whether a location a is between two other locations x and y,
    # i.e. above x and downstrean of y.

    if IsAbove(a,x) == 1 and IsAbove(y,a) == 1:
        if a != x:
            return(1)
    else:
        return(0)

def Overlaps(x,y,T):
    # Determines whether two paths in the tree overlap and gives the locations
    # in both.
    # takes as imput two lists x and y, each a source and target for a theta
    # in a given tree T
    Locations = interactions(T)
    Intersection = []
    for loc in Locations:
        if IsBetween(loc, x[2], x[1]) == 1 and IsBetween(loc, y[2], y[1]):
            Intersection.append(loc)
    return(Intersection)

def Height(loc, T):
    count = 0
    for edge in Edges(T):
        if IsAbove(loc, edge) == 1:
            count = count + 1
    return(count)

def Leaves_Above(v,T):
    # Returns a list of the leaves above a given location
    templist = []
    if IsVertex(v) == 1:
        if type(v[0]) == list:
            return(Leaves_Above([v[0]],T))
        else:
            return(Leaves_Above(v[0],T))
    if IsInput(v) == 1:
        return([v])
    if IsEdge(v) == 1:
        for leaf in Leaves(T):
            if IsAbove(leaf, v) == 1:
                templist.append(leaf)
        return(templist)

###############################################################################
# MISC PROCEDURES
###############################################################################

def Zeros(n):
    # Generates a list of length n contiaining all zeros. Used for initialising
    # lists of a fixed length.
    templist = []
    for i in range(0,n):
        templist.append(0)
    return(templist)

def prodlist(L):
    # Given a list of lists L = [L1, ..., Ln] returns the product list, i.e. a list
    # L1 x ... x Ln whose entries are lists with first entry form L1, second from L2,
    # etc.
    prod = list(itertools.product(*L))
    templist = []
    # Itertools outputs tuples: we want lists for that the data type is mutable.
    for item in prod:
        item = list(item)
        templist.append(item)
    return(templist)

def ItemPrint(list):
    # prints each element of a given list on a new line
    for item in list:
        print(item)

def Reduce(list):
    templist = []
    for item in list:
        count = 0
        for item2 in templist:
            if item == item2:
                count += 1
        if count == 0:
            templist.append(item)
    return(templist)

def Derive(k, L):
    # treating L as an integer vector representing a monomial, this returns
    # the representative of the monomial under the x_k derivative.
    temp = []
    for item in range(0,k):
        temp.append(L[item])
    temp.append(L[k] - 1)
    for item in range(k+1,len(L)):
        temp.append(L[item])
    return(temp)
